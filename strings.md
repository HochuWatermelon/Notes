Здесь изложены основные идеи работы со строками.

Во всех вариках со строками есть буфер, его размер 32 байта, 1 из них будет занят нуль-терминатором (\0) или байтом с кол-вом символов в строке в зависимости от вида строки - cstr или pstr, соответственно. Буфер по заданию заполняем символами '-' ```buffer:		.byte '________________________________'```. Его нужно обязательно поместить в начало секции .data, чтобы он занимал байты в памяти [0..31], так как тесты отслеживают состояние этих ячеек после выполнения программы, сравнивая с ожидаемым содержимым буфера:

![image](https://github.com/user-attachments/assets/d33e2dca-6356-46bb-91e8-4ac2aeb1d19c)

# Указатель
Заводим ptr для итерации по символам строки, кладем в него начало буфера (адрес метки, указывающей на буфер), для перемещения к следующему символу увеличиваем его значение на 1.
 

# Загрузка символа (byte)
Начинаем считывать из ввода 0x80 символы (1 байт) и обрабатывать их. Ни в одной архитектуре нет команды, позволяющей загрузить байт, приходится загружать word. Если нужно работать именно с байтом, как в нашем случае, нужно обязательно делать логическое умножение считанного слова с 0xFF (маска для получения младшего байта), все остальные байты word занулятся. Если спросят, почему нельзя считывать из 0x80 целое слово, ответьте, что слово это 4 символа, а порты ввода-вывода являются посимвольными, то есть на вход за раз подается только один символ (про вывод то же самое, маской выделяем один байт, то есть символ).

# Сохранение символа (byte)
После определенной обработки полученного символа нужно выгрузить его в буфер. И вот здесь возникают расхождения между архитектурами. В risc-iv это делается фешенебельно с помощью команды sb - store byte. А вот acc32 и f32a имеют только команды для сохранения word в память. И тут возникает проблема с тестами, в них зашито конкретное значение буфера и расхождений быть не должно. На скрине верхний буфер - результат программы, нижний - тот, что требует тест. Отличие в трех нулевых байтах, которые стоят после последнего символа. Возникли они потому, что мы вставляем слово в буфер, младший байт будет нашим символом, а вот старшие 3 байта будут заполнены нулями (кста, вы видите пример little to big организации хранения данных, то есть от младшего байта к старшему). Фиксим это путем прибавления к загружаемому символу 0x5F5F5F00, то есть младший байт заполнится нашим символом, а старшие байты будут содержать код символа '-'.

![image](https://github.com/user-attachments/assets/5652153d-2331-4865-951e-86625f61f1f3)

Второй момент - это тесты, которые заполняют на фул буфер. При вставке последнего символа мы также загружаем в память слово, то есть помимо 31 байта заполнятся еще и [32..34]. Они по-любому заняты какими-то полезными данными, так как память непрерывна, и чтобы эти 3 байта не подпортили прическу ячейкам, после буфера вставляем empty_space, который примет в себя те 3 байта, либо увеличиваем буфер на 3 байта (при этом это не увеличение возможного кол-ва принимаемых символов, оно все еще равно 31 максимум) 

![image](https://github.com/user-attachments/assets/882f296f-d514-4a56-b824-b718c55ea694)

![image](https://github.com/user-attachments/assets/b5456f64-ebfa-4aa7-992d-5c6b74d37d47)



# cstr
Си-строки, в конце строки находится нуль-терминатор, то есть символ \0, его код в таблице это 0, соответственно при выводе строки мы считываем очередной символ и смотрим, если считали 0, то этот символ уже не выводим и выходим из цикла вывода. Чтобы вывести строку загружаем указатель на начало строки и в конце каждой итерации увеличиваем его на 1, чтобы перейти к следующему символу. В конце чтения ввода мы после последнего символа в буфер помещаем символ \0.


# pstr
Паскальные строки, в начале строки находится байт с количеством символов в строке. При выводе строки загружаем указатель на начало строки, помним, что первый байт - это длина строки, поэтому берем его за количество итераций (loop_counter, который будет либо в переменной и уменьшаться с выводом каждой буквы, либо сохраняться на вершине стека). Байт, следующий за первым, уже пойдет в вывод. При вводе должен вестись подсчет поступивших символов, по окончании ввода это кол-во символов мы пишем перед буфером, для этого заранее заводим buf_size: .byte 0, в который загрузится длина строки. buf_size увеличивается на 1 и сохраняется после ввода каждого символа (удобно юзать в acc32 и f32a, так как если мы будем делать сохранение в конце, то мы затрем 3 байтами считанные символы, поэтому после каждого считанного символа загружаем содержимое метки, указывающей на кол-во символов, увеличиваем на 1 и сохраняем, при этом старшие байты затираться не будут) или, если вели подсчет общего числа поступивших символов, то сохраняем разово (удобно в risc-iv, так как есть sb команда).


# overflow
В буфере максимум 32 бита, нужно контролить, чтобы не было переполнениям.

1. По указателю: каждую итерацию мы увеличиваем указатель на 1, если в конце итерации он стал равен 31 в cstr (в конце строки еще должно остаться место для \0) или 32 в pstr (адрес первого за буфером байта), а строка еще не закончилась, то возвращаем переполнение - на выход подаем 0xCCCC_CCCC 

2. По количеству считанных элементов: если учли байт с длиной строки или \0, то переполнение возвращаем, если в конце итерации общее число символов стало равно 32. Если не учитывали тот байт, то выход по достижении 31 считанного символа.

# Варианты c изменением регистра букв в строке
Думайте, каким образом будет работать нужный алгоритм преобразования строки в отрыве от программной реализации. Для примера, если мы получили строчную букву, то чтобы сделать ее заглавной, нам нужно отнять 0x20 или 32 в десятичной, это видно в таблице по ссылке ниже:

https://www.industrialnets.ru/files/misc/ascii.pdf




