В f32a Пенской не подвез команды для деления, нахождения остатка и умножения, но подвез команды, которые делают всего один шаг этих операций (так как работаем с 32 разрядными числами, нужно 32 шага)
         
(ﾉ◕ヮ◕)ﾉ*:･ﾟ✧

Лан, че бубнить, погнали ботать
### о DIVный новый мир
Это пример, когда нам нужно поделить число n на счетчик цикла и проверить, делится ли оно без остатка

```
.data
divisor:          .word 0x88

.text
    @p number					             \ dividend
    @p counter					           \ divisor
    @p divisor b!                  \ B <- divisor_label, в регистре b окажется 0x88
    !b                             \ [B] <- divisor, т.е. кладем в 0x88 делитель

    a!                             \ A <- dividend
    lit 0 lit 0                    \ первый нолик для результата деления, второй для остатка

    lit 31 r>                      \ 32 раза будет исполняться multiply_begin, почему так читайте в гайде f32a команда next

multiply_begin:
    +/                             \ это один шаг деления
                                   
    next multiply_begin            \ проверяем, стал ли R нулем, если нет, то продолжаем делать шаги деления

    drop                          \ сверху стека после всех предыдущих действия будет лежать результат деления, он нам не нужен,в случае, когда мы хотим проверить остаток, поэтому выкидываем его
    if remainder_is_zero          \ сейчас на вершнине стека лежит остаток, и мы проверяем равен ли он нулю, если равен, то переходим к обрабоке
```
### Эх, сейчас бы MULаточку
```
         @p first_multiplier      \ этот парниша константа по ходу умножения, то есть никаким сдвигам не будет подвергаться
         @p second_multiplier     \ этот парниша будет свигаться на 1 бит вправо, мы будет проверять его последний бит
	a!                       \ второй множитель грузим в регистр a
	lit 0                    \ здесь будет накапливаться старшая часть результата
	lit 31 >r                \  32 раза будет исполняться multiply_do, почему так читайте в гайде f32a команда next
multiply_do:
    +*                       \ на верхушке стека старшая часть результата, под ним первый множитель; младшая часть результа в a
    next multiply_do
	
	drop drop a        \ первый drop - удаляем старшую часть результа (в вариках обычно переполнение проверяется тем, что младшая часть результата неотрицательное число, поэтому старшая не используется), второй drop удалет первый множитель, далее команда a , которая пушит на вершину стека младший часть результата умножения
	dup                
	-if	multiply_finish \ проверка результа, если получилось отрицательное число, то переполнение 
	multiply_overflow ;
```
Разберемся в реализации одного шага умножения:
```
a <- getA          \ ну ок
t <- dataPop       \ лан
s <- dataPop       \ хорошо
\ ниже происходит проверка, если младший бит содержимого регистра a (0 бит) равен 1, то мы к t прибавляем const первый множитель (лежит в s), сохраняем в t', если 2 * 3, то к нулю 2 раза прибавится тройка
let t' = t + if testBit a 0 then s else 0
\ в трех строках ниже младший бит t' становится 31 битом a'', там с промежуточными регистрами будьте внимательными, но если без уточнения регистров
\ то мы взяли сдвинули a вправо на 1 бит, загрузили на место освободившегося 31 бита младший бит t, далее сдвинули t на 1 бит вправо
         a' = a `shiftR` 1
         t'' = t' `shiftR` 1
         a'' = if testBit t' 0 then setBit a' 31 else clearBit a' 31
dataPush s         \ пушим константный первый множитель
dataPush t''       \ пушим старшую часть результата
setA a''           \ обновляем содержимое a
```
