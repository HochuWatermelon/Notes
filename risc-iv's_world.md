https://github.com/ryukzak/wrench/blob/master/docs/risc-iv.md

Жирков вайбы, у кого были япы уже, в принципе, шарит за эту архитектуру

Итак, у нас есть 7 регистров для хранения данных t0-t6, в них можем загружать данные, адреса,  кароче все кроме своих нюдсов(
Это делает архитектуру очень удобной для работы.

Машинное слово - это инструкция, в risc-iv она занимает 4 байта (для вас это строка в программе). После изучения команд для практики можете определить, к какому формату инструкций относится каждая из них
![image](https://github.com/user-attachments/assets/74b67782-a49c-4268-be86-ac12d47863ff)


Адрес ячейки памяти занимает 32 бита (целое слово), чтобы поместить его или число (immediate value) размером больше 20 бит в регистр нужно воспользоваться комбинацией команд:
```
lui  a0, %hi(address)    ; Load upper 20 bits into a0
addi a0, a0, %lo(address) ; Add lower 12 bits to a0
```
Первая команда загружает в регистр старшие 20 битов с помощью директивы %hi  ```rd <- (symbol & 0xFFFFF000)```, вторая загружает младшие 12 битов с помощью директивы %lo  ```rd <- rs + (symbol & 0x00000FFF)```. Это делается с помощью побитового умножения на маску.
Необходимость их использование объясняется тем, что в стандартных инструкциях не предусмотрена возможность загружать 32 битное значение, ибо не хватит места для всяких опкодов, адресов rd и rs регистров и т.д. 
![image](https://github.com/user-attachments/assets/6c142fbb-806a-4d11-a5a7-902acf1f185e)
![image](https://github.com/user-attachments/assets/57227ae9-1a48-422c-bda8-f5b6a2f2e130)

Обязательным условием для сдачи этой архитектуры является реализация вложенных процедур. В risc-iv есть специально отведенный под сохранение адреса возврата регистр ra. Если вы захотите сделать вызов процедуры из процедуры, то предыдущее значение ra (адрес возврата из первой процедуры) заменится адресом возврата из второй процедуры. Чтобы предотвратить потерю адреса возврата из первой процедуры, перед вызовом второй кладем значение ra на стек, после возврата восстанавливаем значение ra со стека. Где-нибудь в начале программы инициализируем указатель стека таким образом (0x256 было в примере Пенского, но может быть и другое значение, если будет спрашивать, откуда взялось это значение, говорите, что посмотрели в секцию dump, чекнули где кончается программа, и выбрали в качестве начального значения указателя стека адрес, находящийся на достаточном расстоянии от конца программы):
```
	lui     sp, %hi(0x256)                
    	addi    sp, sp, %lo(0x256)
```
Это нужно, чтобы указать с какого места будет начинаться наш стек (мы должны выбрать такой адрес, чтобы стек не налазил на программу ниже). Стек растет вниз, поэтому при его заполнении мы из указателя стека будем вычитать значения, кратные 4 для сохранения элементов. Вот пример:
```
	addi		sp, sp, -4
	sw		ra, 0(sp)
	jal		ra, print_pstr
	lw		ra, 0(sp)
	addi    	sp, sp, 4
	
```
Выделили 4 байта на стеке под ra, после возврата из процедуры print_pstr восстановили значение ra, а также вернули указатель вершины стека в изначальное состояние.

Также нужно проговорить, что есть регистры a0-a7, используемые для передачи входных аргументов в процедуры и возврата значений из нее. В основном, для таких целей используются именно a0 и a1. Также с помощью них нужно заводить константы, которые используются в нескольких процедурах, к примеру ```addi a2, zero, 1 ``` положили константную единицу для использования в основной и вложенной процедуре. Временные регистры ```t``` для таких целей использовать нельзя (несохраняемые регистры, они доступны только в пределах текущей процедуры, где и были инициализированы). Поэтому смотрите на все ```a``` регистры в своей программе и задавайте вопрос, почему я не могу использовать для этой цели регистр ```t```.



## Описание доступных команд (rd - destination register, в него записывается результат; rs1 и rs2 - source registers - регистры-источники; k - immediate value -число, которое без изменений подставляется в качестве операнда в команды, в командах перехода k - это адрес, на который указывает метка)

# ```addi <rd>, <rs1>, <k>```
Что делает:
```
rd <- rs1 + k
```

Пояснение:
К содержимому регистра rs1 добавляется непосредственное значение записанное числом k,результат записывается в rd. Из формата инструкций помним, что число k максимум 12 бит, а еще в rd сохраняются только 12 младших бит результата, остальные 20 битов заполняются 1 или 0, в зависимости от знака результата.

Пример использования:
```
.text
_start:
	addi	t2, t2, -1
```

Что произошло после выполнения:
К примеру, в регистре t2 у нас хранится кол-во итераций цикла, с помощью addi мы уменьшаем значение t2 на 1, в acc32 для этого нам пришлось бы заводить константу, спасибо разрабам, что подвезли сюда immediate values


# ```add <rd>, <rs1>, <rs2>```
Что делает:
```
 rd <- rs1 + rs2
```

Пояснение:
Содержимое регистра rs1 складывается с rs2 и результат пишется в rd (похожий принцип и у других арифметических и логических операций, смотрите доку Пенского, ссылка в начале гайда)

Пример использования:
```
addi t0, t0, 1
addi t1, t1, 2
add t3, t0, t1
```

Что произошло после выполнения:
в t3 будет записана 3, так как 1 + 2 = 3, ладно.

# ```mv <rd>, <rs>```
Что делает:
```
rd <- rs
```

Пояснение:
В регистр rd помещается значения регистра rs, при этом содержимое rs остается неизменным

Пример использования:
```
addi t1, t1, 6
addi t2, t2, 100
mv t1, t2
```

Что произошло после выполнения:
В начале программы все регистры содержат 0. В примере показано, как можно с помощью addi инициализировать значение регистров, то есть в t1 положили 6, в t2 - 100
После выполнения в t1 окажется 100 баллов на Rotten Tomatoes

# ```lw <rd>, <offset>(<rs1>)```
Что делает:
```
rd <- M[offset + rs1]
```

Пояснение:
M[...] - это обращение к памяти
Загрузка слова целиком происходит из адреса, который получается суммированием адреса, лежащего в регистре из скобок, а также смещения offset. Если смещение 0, то загрузка происходит напрямую из адреса, записанного в регистр. Если немного знакомы с синтаксисом языка C,  то 0(t0) похоже на разыменование адреса в C, то есть *ptr, к примеру. Если мы работаем с массивами, то offset можно использовать для доступа к отдельным элементам, то есть 0(t0) это первый элемент, 4(t0) это второй и т.д (4, потому что размер инструкции 4 байта, помним, гордимся)

Пример использования:
```
	.data
output_addr:   .word 0x84

	.text
_start:
write_output:
	lui     t0, %hi(output_addr)
    	addi    t0, t0, %lo(output_addr)
	lw		t0, 0(t0)	; t0 = 0x84
    	halt
```

Что произошло после выполнения:
С помощью комбы lui + addi + желание закрыть АК мы загрузили в t0 адрес ouput_addr, по нему, как видно в секции .data лежит 0x84, смещение 0, поэтому обращаемся напрямую к output_addr и загружаем в t0 значение 0x84

# ```sw <rs2>, <offset>(<rs1>)```
Что делает:
```
M[offset + rs1] <- rs2
```

Пояснение:
Сохранение слова целиком идет напрямую в адрес, который получается суммированием адреса, лежащего в регистре, который указывается в скобках, а также смещения offset. Если смещение 0, то сохранение происходит напрямую в адрес, записанный в регистр. 

Пример использования:
```
	.data
output_addr:   .word 0x84

	.text
_start:
workaem:
	addi t5, t5, 69
write_output:
	lui     t0, %hi(output_addr)
    	addi    t0, t0, %lo(output_addr)
	lw		t0, 0(t0)	; t0 = 0x84
	sw		t5, 0(t0)
    	halt
```

Что произошло после выполнения:
В t5 у нас хранится какое-то значение, которое нужно вывести как результат работы программы, lw загрузила 0x84 в t0, теперь с помощью 0(t0) в команде sw мы пишем напрямую содержимое t5 в 0x84, nice. 

# ```sb <rs2>, <offset>(<rs1>)```
Что делает:
```
M[offset + rs1] <- rs2 & 0xFF
```

Пояснение:
Логика такая же, как и с sw, только в данном случае сохраняется не слово, а лишь его младшие 8 бит, используется, к примеру, в строках, когда нам надо выводить символ (8 бит) один за другим.



# ```j <k>```
Что делает:
```
pc <- pc + k
```

Пояснение:
Безусловный переход к метке

Пример использования:
```
    j     end
end:
    halt
```

Что произошло после выполнения:
Был совершен переход к метке end


# ```jr <rs>```
Что делает:
```
pc <- rs
```

Пояснение:
Безусловный переход к адресу, который сохранен в регистре rs. Необходим для возврата из функций, к примеру.

Пример использования:
```
	; Проще показать это вместе со следующей командой
```



# ```jal <rd>, <k>```
Что делает:
```
rd <- pc + 4, pc <- pc + k
```

Пояснение:
Мы совершаем переход к метке, при этом сохраняем значение адреса следующей команды в регистре (адрес возврата). Вспоминаем прерывания или вызов функции. Вызываем обработку функции и после ее завершения необходимо вернуться на то же место, откуда была вызвана функция, и перейти к следующей строке программы.

Пример использования:
```
    jal r0, some_work
    halt
    some_work:
	addi t1, t1, 5
	jr   r0

```

Что произошло после выполнения:
Командой jal мы поместили адрес строки с halt и перешли к метке some_work, в конце some_work с помощью команды jr достали из r0 адрес возврата и поместили его в pc, произведя при этом переход к halt, машина закончила трудиться

# ```beqz <rs1>, <k>```
Что делает:
```
if rs1 == 0 then pc <- pc + k
```

Пояснение:
Условный переход на метку, если содержимое rs1 это ноль.

Пример использования:
```
    mv t1, zero
    beqz t1, it_is_zero
it_is_zero:
    halt
```

Что произошло после выполнения:
mv t1, zero - помещает в t1 нолик, zero - это специальный регистр, в котором всегда лежит 0, его необходимость в том, что некоторые команды не поддерживают immediate value, а обнулять регистры как-то надо, обожаю разрабов бож
Будет совершен переход к метке, так как в t1 лежит 0


# ```bgt <rs1>, <rs2>, <k>```
Что делает:
```
if rs1 > rs2 then pc <- pc + k
```

Пояснение:
Условный переход, если содержимое rs1 больше, чем rs2. Отличается от предыдущей команды кол-вом аргументов

Пример использования:
```
    addi  t1, t1, 999
    li    t2, t2, 52
    bgt   t1, t2, t1_gt_t2
t1_gt_t2:
    halt
```

Что произошло после выполнения:
Будет совершен переход к метке, так как в t1 лежит число большее, чем в t2. Остальные команды условного перехода смотреть в доке (там будут еще unsigned их версии, чтобы сравнивать беззнаковые числа)


