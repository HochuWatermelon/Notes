# Что такое метка (label)?
Метка в ассемблере - это имя, которое указывает на конкретное место в программе, на которое можно сослаться в коде.

ИЛИ

Метка - это ссылка на адрес в памяти, в котором хранятся данные.

ИЛИ

Метка — это средство задания точки в программе или сред­ство хранения значения постоянных и переменных. 

ИЛИ

Мб пойдём погуляем куда-нибудь, ну этот АК не?

Необходимы для повышения человекочитаемости кода. С помощью них удобно создавать подобие переменных в секции .data, а также обращаться к отдельным участкам программы, т.е. совершать переходы 

Сами по себе метки не занимают место в памяти.

Должны иметь уникальные имена.

В dump отчёта wrench есть отдельная область, в которой видно, на какой адрес та или иная метка ссылается (как это считается объяснил в следующем вопросе)

![image](https://github.com/user-attachments/assets/0a4b4381-17f0-4241-8e3d-fc430ed46759)

# Откуда рассчитываются значения меток (label)?
Ассемблер делает два прохода по тексту программы. На первом проходе проверяется правильность синтаксиса и рассчитываются
значения меток. Тому, как он это делает, и будет посвящена наша сегодняшняя история.

Ассемблер идет последовательно, начиная с начала сегмента .data (ячейка памяти с адресом 0)
Он считает размер каждой директивы (.byte, .word) или инструкции в байтах, а когда встречает метку - присваивает метке значение,
равное текущему счетчику байтов в таблице значений меток (пикча из первого вопроса) 
Размер каждой инструкции известен ассемблеру (зависит от архитектуры)

На втором проходе ♂ass♂embler чекает таблицу значений из первого прохода и подставляет в код
вместо меток реальные адреса.

# Как вывести в отчёте состояние регистра Acc в hex формате?
Возьмём, к примеру, f32a
В доке Пенского для каждой архитектуры есть список возможных представлений состояний регистров

![image](https://github.com/user-attachments/assets/7797acfa-80fa-44e4-8a48-a1fd88a4d0f7)

В yaml config (simulation_config поле в отчете wrench) в разделе view (между slice и assert) прописываем регистры, состояния которых мы хотим видеть, с припиской hex.
На примере ниже вывели stack в шестнадцатиричном формате. Slice: all позволяет отслеживать состояние регистров после каждой комнады.

![image](https://github.com/user-attachments/assets/5bd92413-b3af-45ed-ac6b-0a07196c6c17)


Вот, что мы будем видеть в во вкладке simulation_log:

![image](https://github.com/user-attachments/assets/82cdf1a7-1c27-4e2b-bc5a-c86c3abb4981)

А вот Carry флаг, как мы видим по первой картинке, в hex вывести не получится, ну и пох

Разберём, как выводить Acc

Для acc32:

![image](https://github.com/user-attachments/assets/7a361aa8-877b-4e55-925d-44162c460dc6)

Прописываем в yaml config:
```
slice: all
view: |
      {pc}:	{instruction}	{pc:label} Acc: {Acc:hex}
```
Тогда в simulation_log такую тему увидим:
 ```
19:	Add 8	 Acc: 0x00000008
```

# Что такое Memory Mapped IO?
У нас есть различные устройства ввода-вывода. С ними нужно обмениваться инфой, то есть принимать для обработки данные и отправлять полученные результаты. Memory Mapped IO позволяет процессору работать с устройствами как с обычными адресами в памяти (команды чтения и записи). То есть он пишет в адрес или читает из него, а на самом деле происходит обращение к устройству. То есть мы мапим определенный адрес, к примеру 0x80, и говорим, что это input port. 

Это необходимо для того, чтобы, во-первых, не создавать отдельное адресное пространство для портов ввода-вывода, а во-вторых, не заводить специальные инструкции для операция записи и чтения из этих портов.
# Что будет, если процессор попытается прочитать инструкцию из адреса ввода-вывода?
Адреса input port и output port не предназначены для чтения из них инструкций, а только для обмена данными. Поэтому на аппаратном уровне нам нужно запрещать процессору читать из этих адресов инструкции, то есть когда счетчик команд PC достигнет этого адреса, нужно вызвать исключение/ошибку. Это и происходит, кста, выглядит таким образом:

![image](https://github.com/user-attachments/assets/a7b2d96a-c180-43cf-bfb0-654229f33ca5)


# Назначение alignment (неиспользуемый буфер в секции данных)?

![image](https://github.com/user-attachments/assets/f5d2a493-d960-4fd2-b413-f80fa1032b91)


Бу, испугался, не бойся

Берем это

```alignment:     .word '＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_＼(≧▽≦)／_'```

И опа

![image](https://github.com/user-attachments/assets/4d66b6b8-3269-4694-af8e-1815685cc00b)

Помним, что процессору нельзя читать инструкции из адресов ввода-вывода. В нашем случае 128 (0x80) и 132 (0x84). input_port занимает место в памяти [128..131], output_port - [132..135] Если инструкция будет содержать хотя бы одну из ячеек с 128 до 135, то произойдет наложение с памятью, выделенной для портов ввода-вывода и возникнет ошибка ```instruction in memory corrupted``` или ```can't read from input port```

Посмотрим на dump до alignment. Видим, что инструкция load_ind содержит в себе ячейку 128, куда не надо полезла, согласны? Сообщим ей ласково с помощью alignment, чтобы она подвинулась. Инструкции могут начинаться с 136 ячейки включительно. 136-128 = 8, делим на 4, получаем 2 байта. Таким образом, если мы сдвинем эту инструкцию на 2 байта, то она будет начинаться с 136. Просто вставляем эти 2 байта в alignment  

![image](https://github.com/user-attachments/assets/2b22ba4c-f173-4cda-a2b5-3d21d8376728)

Пример рассчета эффективного по памяти alignment. Видим, что _start на скрине ниже лежит по адресу 44, это и есть адрес первой исполняемой инструкции. Из 136 вычитаем 44, получаем 92, 92 делим на 4 (байтов в word) = 23. Это и будет размер нашего alignment. Так он будет выглядеть ``` alignment:          .word '***********************' ```, в нем 23 * 4 байта. Вставляем его в конец секции .data Кста, alignment можно заполнять любыми символами.

![image](https://github.com/user-attachments/assets/7e4eccff-9bd0-4e38-8179-e2b3e9d1737d)

Но alignment нужен не в каждой программе, если она у вас целиком помещается в памяти до 128 ячейки, то этот парниша не нужен.

# acc32 Зачем определены дублирующиеся инструкции load_addr и load?
Читайте про это в гайде к acc32, эти команды описаны подробно.
# acc32 Переполнение и перенос. Overflow и Carry флаги, иные способы обработки.
Что такое переполнение (не гордостью, что работаете со мной) и перенос (не дел на завтра) при битовых операциях, я надеюсь вы знаете. В acc32 их проверка происходит с помощью
операций условного перехода по состоянию флага, а также их очистка с помощью команд опять же.

Вопрос об иных способах обработки расплывчатый, но предположим. 1 способ. Если у вас был дискродед на первом курсе, то шарите, как это можно сделать с помощью анализа старшего бита каждого из
операндов и старшего бита результата. Вот, к примеру, я расписывал все возможные комбы для вычисления, будет ли carry или нет, где a - старший бит операнда a, b - b, r - r, логично. c - это carry, 1 - установлен, 0 - не установлен. Если будете вникать в эти комбы и думать, почему a = 0, b = 0, a r = 1, к примеру, то помните про возможный перенос 1 при сложении младших разрядов.
Для флага переполнения свои комбы. Итак, в программе это можно реализовать, получится программный контроль флагов, а не аппаратный.

![image](https://github.com/user-attachments/assets/2a8a52ca-b17f-40b3-91d7-6f33d4eeb698)

Есть еще подход, который не поддерживается в нашей архитектуре, но имеет место быть теоретически. Расширение операндов и результата до большего размера, к примеру, 64 бит, выполнение вычислений и далее проверка, что он не выходит за минимальную и максимальную границы 32 битного числа.

Еще как-то мутил другую темку, кароч если нам нужно сделать сложение и проверить, будет ли переполнение, мы из максимально возможного 32-битного числа отнимаем второй операнд, и проверяем, что если первый операнд больше получившейся разности, то переполнению быть. Вот так вот, братцы.

# Что означает инструкция ...? Объясните что происходит в строках ....
Включаем харизму и поясняем за машинные слова.
# Как сократить объём машинного кода? Какие ограничение/проблемы это создаст?
На примере f32a

```
lit 1
+
```

Целых две команды, но мы ведь знаем, что это доступный в других языках программирования inc. Так вот, чтобы сократить объем машинного кода, мы берём и вводим новые инструкции. У этого подхода есть минус, связанный с увеличением сложности процессора или интерпретатора команд.

Второй подход можно уменьшить размер загружаемых immediate_value или адресов, тогда размер инструкций сократится, но диапазон доступной памяти и данных ограничится.

Про удаление лишних инструкций или алгоритмическое ускорение программы в этом вопросе лучше не говорить, это скорее относится про улучшение написанной вами программы, чем к сокращению объема кода с точки зрения архитектурной организации.
# risc-iv Что означает конструкция 0(t1)? Зачем она нужна?
Описано в гайде по risc-iv. Если кратко, то это по типу указателей на языке C, разыменование адреса.
Если спросят про смещение, расскажите про итерации в массиве.
## risc-iv Почему для загрузки слова регистр нужно две инструкции?
Описано в гайде risc-iv подробно. Продумано с моей стороны.
## f32a Почему в F32a удобно использовать процедуры?
Процедуры - это исполняемые части кода, вызов процедуры делаем с помощью call, возврат из неё - с помощью return.

В f32a очень удобно их использовать благодаря стеку, так как не нужно продумывать передачу аргументов,
они просто кладутся через push на стек, а процедура снимает их через pop(у).

Также существует независимость между процедурами, то есть одна никак не влияет на другую, ведь
можно считать, что у каждой процедуры выделена своя часть стека, с которой она взаимодействует.

Возврат из процедуры тоже бархатно проходит, спасибо стеку возврата, который хранит адреса возвратов.

Также не нужно делать сохранение и восстановление регистров.

Рекурсивные вызовы офигенно работают в стековой архитектуре, опять же благодаря независимому пространству стека
у каждой процедуры.


# f32a Extended arithmetic mode. Назначение и использование.
Гайд, мои дорогие, в нём все ответы. 

Вот вам ёжик смешной, а то подумаете еще, что я халтурю

![image](https://github.com/user-attachments/assets/9b761222-444d-4c5e-ac02-7ec66fa4fe95)

# Особенности кодирования инструкций, плотность кода, проблемы доступа.
Особенности кодирования инструкций: Есть архитектуры с фиксированной длиной инструкций, к примеру, risc-iv все по 4 байта, а есть архитектуры с переменной длиной, к примеру, в f32a есть по 5, 1, ил 4 байта. К недостаткам первой можно отнести низкую плотность кода, но при этом такие инструкции легко декодировать, ведь заранее известно, через сколько байт закончится инструкция. К недостаткам второй относится более сложное декодирование (необходим механизм, определяющий длину инструкции), однако это окупается высокой плотностью кода (простые операции занимают меньше места в памяти)

Плотность кода:
Нужно выполнить набор команд. Высокая плотность кода будет означать, что программы будут использовать меньшее количество памяти для выполнения определенного функционала, чем программы с более низкой плотностью кода. Грубо говоря, плотность показывает, насколько эффективно используются n ячеек памяти для решения поставленной задачи.

Проблемы доступа:
Гонки за владение ресурсами при многопоточной обработке, недоступность для ввода-вывода устройств, ограничения размера памяти, перегрузка шины данных из-за большого числа устройств и тд.
# Как вы можете сократить объём машинного кода? Продемонстрируйте.
Спорный вопрос, по идее возникнуть не должен, так как я уверен, что делал все максимально эффективно, но всякое бывает. На практике, к примеру, повторяющиеся участки кода можно выделить в одну процедуру и вызывать её, это сократит объем кода. Просто, смотрите на куски кода и думаете, как я могу это сделать за меньшее число команд. Как вариант, можно добавить чутка неэффективности в программу для защиты от пу-пу-пууу во время ответа на этот вопрос на сдаче.
# risc-iv Работа со стеком. Выделение памяти, передача данных в/из процедур.
Сбор инфы. Stay tuned.
 




 


